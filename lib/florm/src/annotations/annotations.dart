

import 'package:meta/meta.dart';

/// Specifies that the class is an entity.
/// This annotation is applied to the entity class.
class Entity {
  /// The entity name. Defaults to the unqualified name of the entity class.
  /// This name is used to refer to the entity in queries. The name must not be
  /// a reserved literal in the Java Persistence query language.
  final String name;

  const Entity([this.name = ""]);
}

/// Specifies that the class is an entity.
/// This annotation is applied to the entity class.
const Entity entity = Entity();

/// Specifies the mapped column for a persistent property or field.
/// If no Column annotation is specified, the default values apply.
class Column {
  /// The SQL fragment that is used when generating the DDL for the column.
  /// Defaults to the generated SQL to create a column of the inferred type.
  final String columnDefinition;

  /// The name of the table that contains the column. If absent the
  /// column is assumed to be in the primary table.
  final String table;

  /// The name of the column. Defaults to the property or field name.
  final String name;

  /// Whether the column is included in SQL INSERT
  /// statements generated by the persistence provider.
  final bool insertable;

  /// Whether the column is included in SQL UPDATE statements
  /// generated by the persistence provider.
  final bool updatable;

  /// Whether the database column is nullable.
  final bool nullable;

  /// Whether the column is a unique key.
  final bool unique;

  /// The precision for a decimal (exact numeric) column.
  final int precision;

  /// The column length.
  final int length;

  /// The scale for a decimal (exact numeric) column.
  final int scale;

  const Column({
    this.columnDefinition = "",
    this.table = "",
    this.name = "",
    this.insertable = true,
    this.updatable = true,
    this.nullable = true,
    this.unique = false,
    this.precision = 0,
    this.length = 255,
    this.scale = 0,
  });
}

/// Specifies the mapped column for a persistent property or field.
/// If no Column annotation is specified, the default values apply.
const Column column = Column();

/// Specifies a collection of instances of a basic type or embeddable class.
/// Must be specified if the collection is to be mapped
/// by means of a collection table.
class ElementCollection {
  ///  Whether the collection should be lazily loaded or must be eagerly fetched.
  final FetchType fetch;

  /// The basic or embeddable class that is the element type of the collection.
  final Type targetClass;

  const ElementCollection({this.targetClass, this.fetch = FetchType.LAZY});
}

/// Specifies a collection of instances of a basic type or embeddable class.
/// Must be specified if the collection is to be mapped
/// by means of a collection table.
const ElementCollection elementCollection = ElementCollection();

/// Specifies a class whose instances are stored as an intrinsic part of an
/// owning entity and share the identity of the entity. Each of the persistent
/// properties or fields of the embedded object is mapped to the database
/// table for the entity. Note that the Transient annotation may be used to
/// designate the non-persistent state of an embeddable class.
class Embeddable {
  const Embeddable();
}

/// Specifies a class whose instances are stored as an intrinsic part of an
/// owning entity and share the identity of the entity. Each of the persistent
/// properties or fields of the embedded object is mapped to the database
/// table for the entity. Note that the Transient annotation may be used to
/// designate the non-persistent state of an embeddable class.
const Embeddable embeddable = Embeddable();

/// Specifies a persistent field or property of an entity whose value is
/// an instance of an embeddable class. The embeddable class must be
/// annotated as Embeddable. The AttributeOverride, AttributeOverrides,
/// AssociationOverride, and AssociationOverrides annotations may be
/// used to override mappings declared or defaulted by the embeddable class.
class Embedded {
  const Embedded();
}

/// Specifies a persistent field or property of an entity whose value is
/// an instance of an embeddable class. The embeddable class must be
/// annotated as Embeddable. The AttributeOverride, AttributeOverrides,
/// AssociationOverride, and AssociationOverrides annotations may be
/// used to override mappings declared or defaulted by the embeddable class.
const Embedded embedded = Embedded();

/// Specifies that the property or field is not persistent.
/// It is used to annotate a property or field of an entity class,
/// mapped superclass, or embeddable class.
class Transient {
  const Transient();
}

/// Specifies that the property or field is not persistent.
/// It is used to annotate a property or field of an entity class,
/// mapped superclass, or embeddable class.
const Transient transient = Transient();

/// Defines mapping for enumerated types. The constants of this enumerated type
/// specify how a persistent property or field of an
/// enumerated type should be persisted.
enum EnumType {
  /// Persist enumerated type property or field as an integer.
  ORDINAL,

  /// Persist enumerated type property or field as a string.
  STRING
}

/// Specifies that a persistent property or field should be persisted
/// as a enumerated type. The Enumerated annotation may be used in conjunction
/// with the Basic annotation, or in conjunction with the ElementCollection
/// annotation when the element collection value is of basic type.
/// If the enumerated type is not specified or the Enumerated annotation
/// is not used, the EnumType value is assumed to be ORDINAL.
class Enumerated {
  /// Defines mapping for enumerated types. The constants of this enumerated type
  /// specify how a persistent property or field of an
  /// enumerated type should be persisted.
  final EnumType enumType;

  const Enumerated([this.enumType = EnumType.ORDINAL]);
}

/// Specifies that a persistent property or field should be persisted
/// as a enumerated type. The Enumerated annotation may be used in conjunction
/// with the Basic annotation, or in conjunction with the ElementCollection
/// annotation when the element collection value is of basic type.
/// If the enumerated type is not specified or the Enumerated annotation
/// is not used, the EnumType value is assumed to be ORDINAL.
const Enumerated enumerated = Enumerated();

/// Used to control the application of a constraint.
enum ConstraintMode {
  /// Apply the constraint
  CONSTRAINT,

  /// Do not apply the constraint.
  NO_CONSTRAINT,

  /// Use the provider-defined default behavior.
  PROVIDER_DEFAULT
}

/// Used to specify the handling of foreign key constraints when schema
/// generation is in effect. If this annotation is not specified,
/// the persistence provider's default foreign key strategy will be used.
/// The ConstraintMode value is used to specify whether foreign key constraints
/// should be generated.
/// The syntax used in the foreignKeyDefinition element should follow the SQL
/// syntax used by the target database for foreign key constraints.
/// For example, this may be similar the following:
/// FOREIGN KEY ( <COLUMN expression> {, <COLUMN expression>}... )
/// REFERENCES <TABLE identifier> [
///     (<COLUMN expression> {, <COLUMN expression>}... ) ]
/// [ ON UPDATE <referential action> ]
/// [ ON DELETE <referential action> ]
/// When the ConstraintMode value is CONSTRAINT, but the foreignKeyDefinition
/// element is not specified, the provider will generate foreign key constraints
/// whose update and delete actions it determines most appropriate for the join
/// column(s) to which the foreign key annotation is applied.
class ForeignKey {
  /// The foreign key constraint definition.
  final String foreignKeyDefinition;

  /// The name of the foreign key constraint.
  final String name;

  final ConstraintMode constraintMode;

  const ForeignKey(
      {this.foreignKeyDefinition = "",
      this.constraintMode = ConstraintMode.CONSTRAINT,
      this.name = ""});
}

/// Used to specify the handling of foreign key constraints when schema
/// generation is in effect. If this annotation is not specified,
/// the persistence provider's default foreign key strategy will be used.
/// The ConstraintMode value is used to specify whether foreign key constraints
/// should be generated.
/// The syntax used in the foreignKeyDefinition element should follow the SQL
/// syntax used by the target database for foreign key constraints.
/// For example, this may be similar the following:
/// FOREIGN KEY ( <COLUMN expression> {, <COLUMN expression>}... )
/// REFERENCES <TABLE identifier> [
///     (<COLUMN expression> {, <COLUMN expression>}... ) ]
/// [ ON UPDATE <referential action> ]
/// [ ON DELETE <referential action> ]
/// When the ConstraintMode value is CONSTRAINT, but the foreignKeyDefinition
/// element is not specified, the provider will generate foreign key constraints
/// whose update and delete actions it determines most appropriate for the join
/// column(s) to which the foreign key annotation is applied.
const ForeignKey foreignKey = ForeignKey();

/// Defines the types of primary key generation strategies.
enum GenerationType {
  /// Indicates that the persistence provider should pick an appropriate
  /// strategy for the particular database.
  AUTO,

  /// Indicates that the persistence provider must assign primary keys
  /// for the entity using a database identity column.
  IDENTITY,

  /// Indicates that the persistence provider must assign primary
  /// keys for the entity using a database sequence.
  SEQUENCE,

  /// Indicates that the persistence provider must assign primary keys
  /// for the entity using an underlying database table to ensure uniqueness.
  TABLE
}

/// Provides for the specification of generation strategies
/// for the values of primary keys. The GeneratedValue annotation may be applied
/// to a primary key property or field of an entity or mapped superclass in
/// conjunction with the Id annotation. The use of the GeneratedValue
/// annotation is only required to be supported for simple primary keys. Use of
/// the GeneratedValue annotation is not supported for derived primary keys.
class GeneratedValue {
  /// The name of the primary key generator to use as specified in the
  /// SequenceGenerator or TableGenerator annotation. Defaults to the id
  /// generator supplied by persistence provider.
  final String generator;

  /// The primary key generation strategy that the persistence provider
  /// must use to generate the annotated entity primary key.
  final GenerationType strategy;

  const GeneratedValue({
    this.strategy = GenerationType.AUTO,
    this.generator = ""
  });
}

/// Provides for the specification of generation strategies
/// for the values of primary keys. The GeneratedValue annotation may be applied
/// to a primary key property or field of an entity or mapped superclass in
/// conjunction with the Id annotation. The use of the GeneratedValue
/// annotation is only required to be supported for simple primary keys. Use of
/// the GeneratedValue annotation is not supported for derived primary keys.
const GeneratedValue generatedValue = GeneratedValue();

/// The mapped column for the primary key of the entity is assumed to be the
/// primary key of the primary table. If no Column annotation is specified,
/// the primary key column name is assumed to be the name of the primary
/// key property or field.
class Id {
  const Id();
}

/// The mapped column for the primary key of the entity is assumed to be the
/// primary key of the primary table. If no Column annotation is specified,
/// the primary key column name is assumed to be the name of the primary
/// key property or field.
const Id id = const Id();

/// Synonymous for @id
const Id id$ = id;

/// Used in schema generation to specify creation of an index.
/// Note that it is not necessary to specify an index for a primary key,
/// as the primary key index will be created automatically.
/// The syntax of the columnList element is a column_list, as follows:
///
///    column::= index_column [,index_column]*
///    index_column::= column_name [ASC | DESC]
///
/// If ASC or DESC is not specified, ASC (ascending order) is assumed.
class Index {
  /// The names of the columns to be included in the index, in order.
  final String columnList;

  /// The name of the index; defaults to a provider-generated name.
  final String name;

  /// Whether the index is unique.
  final bool unique;

  const Index({
    @required this.columnList,
    this.unique = false,
    this.name = "",
  });
}

/// Defines inheritance strategy options.
enum InheritanceType {
  /// A strategy in which fields that are specific to a subclass are mapped to
  /// a separate table than the fields that are common to the parent class,
  /// and a join is performed to instantiate the subclass.
  JOINED,

  /// A single table per class hierarchy.
  SINGLE_TABLE,

  /// A table per concrete entity class.
  TABLE_PER_CLASS
}

/// Specifies the inheritance strategy to be used for an entity class hierarchy.
/// It is specified on the entity class that is the root of the entity class
/// hierarchy. If the Inheritance annotation is not specified or if no
/// inheritance type is specified for an entity class hierarchy,
/// the SINGLE_TABLE mapping strategy is used.
class Inheritance {
  final InheritanceType inheritanceType;

  const Inheritance({this.inheritanceType = InheritanceType.SINGLE_TABLE});
}

/// Specifies the inheritance strategy to be used for an entity class hierarchy.
/// It is specified on the entity class that is the root of the entity class
/// hierarchy. If the Inheritance annotation is not specified or if no
/// inheritance type is specified for an entity class hierarchy,
/// the SINGLE_TABLE mapping strategy is used.
const Inheritance inheritance = Inheritance();

/// Specifies a column for joining an entity association or element collection.
/// If the JoinColumn annotation itself is defaulted, a single join column
/// is assumed and the default values apply.
class JoinColumn {
  /// The SQL fragment that is used when generating the DDL for the column.
  final String columnDefinition;

  /// Used to specify or control the generation of a foreign key constraint
  /// when table generation is in effect.
  final ForeignKey foreignKey;

  /// Whether the column is included in SQL INSERT statements generated
  /// by the persistence provider.
  final bool insertable;

  /// The name of the foreign key column.
  final String name;

  /// Whether the foreign key column is nullable.
  final bool nullable;

  /// The name of the column referenced by this foreign key column.
  final String referencedColumnName;

  /// The name of the table that contains the column.
  final String table;

  /// Whether the property is a unique key.
  final bool unique;

  /// Whether the column is included in SQL UPDATE statements generated
  /// by the persistence provider.
  final bool updatable;

  const JoinColumn({
    this.referencedColumnName = "",
    this.columnDefinition = "",
    this.foreignKey,
    this.insertable = true,
    this.updatable = true,
    this.nullable = true,
    this.unique = false,
    this.table = "",
    this.name = "",
  });
}

/// Specifies a column for joining an entity association or element collection.
/// If the JoinColumn annotation itself is defaulted, a single join column
/// is assumed and the default values apply.
const JoinColumn joinColumn = JoinColumn();

/// Specifies the mapping for composite foreign keys. This annotation groups
/// JoinColumn annotations for the same relationship. When the JoinColumns
/// annotation is used, both the name and the referencedColumnName elements
/// must be specified in each such JoinColumn annotation.
class JoinColumns {
  /// Used to specify or control the generation of a foreign key constraint
  /// when table generation is in effect.
  final ForeignKey foreignKey;

  /// The join columns that map the relationship.
  final List<JoinColumn> value;

  const JoinColumns({
    @required this.value,
    this.foreignKey,
  });
}

/// Specifies that a unique constraint is to be included in
/// the generated DDL for a primary or secondary table.
class UniqueConstraint {
  /// An array of the column names that make up the constraint.
  final List<String> columnNames;

  /// Constraint name.
  final String name;

  const UniqueConstraint({
    @required this.columnNames,
    this.name = "",
  });
}

/// Specifies the mapping of associations. It is applied to the owning side
/// of an association. A join table is typically used in the mapping of
/// many-to-many and unidirectional one-to-many associations. It may also be
/// used to map bidirectional many-to-one/one-to-many associations,
/// unidirectional many-to-one relationships, and one-to-one associations
/// (both bidirectional and unidirectional). When a join table is used in
/// mapping a relationship with an embeddable class on the owning side of the
/// relationship, the containing entity rather than the embeddable class is
/// considered the owner of the relationship. If the JoinTable annotation is
/// missing, the default values of the annotation elements apply.
/// The name of the join table is assumed to be the table names of the
/// associated primary tables concatenated together (owning side first)
/// using an underscore.
class JoinTable {
  /// The catalog of the table.
  final String catalog;

  /// Used to specify or control the generation of a foreign key constraint
  /// when table generation is in effect.
  final ForeignKey foreignKey;

  /// Used to specify or control the generation of a foreign key constraint for
  /// the columns corresponding to the inverseJoinColumns element when table
  /// generation is in effect.
  final ForeignKey inverseForeignKey;

  /// Indexes for the table.
  final List<Index> indexes;

  /// The foreign key columns of the join table which reference the primary
  /// table of the entity owning the association.
  final List<JoinColumn> joinColumns;

  /// The foreign key columns of the join table which reference the
  /// primary table of the entity that does not own the association.
  final List<JoinColumn> inverseJoinColumns;

  /// The name of the join table.
  final String name;

  /// The schema of the table.
  final String schema;

  final List<UniqueConstraint> uniqueConstraints;

  const JoinTable({
    this.inverseJoinColumns = const [],
    this.uniqueConstraints = const [],
    this.joinColumns = const [],
    this.indexes = const [],
    this.inverseForeignKey,
    this.catalog = "",
    this.schema = "",
    this.foreignKey,
    this.name = "",
  });
}

/// Specifies the mapping of associations. It is applied to the owning side
/// of an association. A join table is typically used in the mapping of
/// many-to-many and unidirectional one-to-many associations. It may also be
/// used to map bidirectional many-to-one/one-to-many associations,
/// unidirectional many-to-one relationships, and one-to-one associations
/// (both bidirectional and unidirectional). When a join table is used in
/// mapping a relationship with an embeddable class on the owning side of the
/// relationship, the containing entity rather than the embeddable class is
/// considered the owner of the relationship. If the JoinTable annotation is
/// missing, the default values of the annotation elements apply.
/// The name of the join table is assumed to be the table names of the
/// associated primary tables concatenated together (owning side first)
/// using an underscore.
const JoinTable joinTable = JoinTable();

class _Lob {
  const _Lob();
}

/// Specifies that a persistent property or field should be persisted as a
/// large object to a database-supported large object type. Portable
/// applications should use the Lob annotation when mapping to a database Lob
/// type. The Lob annotation may be used in conjunction with the Basic
/// annotation or the ElementCollection annotation when the element collection
/// value is of basic type. A Lob may be either a binary or character type.
/// The Lob type is inferred from the type of the persistent field or property,
/// and except for string and character-based types defaults to Blob.
const _Lob lob = _Lob();
const _Lob Lob = lob;

/// Defines the set of cascadable operations that are propagated to the
/// associated entity. The value cascade=ALL is equivalent to
/// cascade={PERSIST, MERGE, REMOVE, REFRESH, DETACH}.
enum CascadeType {
  /// Cascade all operations
  ALL,

  /// Cascade detach operation
  DETACH,

  /// Cascade merge operation
  MERGE,

  /// Cascade persist operation
  PERSIST,

  /// Cascade refresh operation
  REFRESH,

  /// Cascade remove operation
  REMOVE
}

/// Defines strategies for fetching data from the database. The EAGER strategy
/// is a requirement on the persistence provider runtime that data must be
/// eagerly fetched. The LAZY strategy is a hint to the persistence provider
/// runtime that data should be fetched lazily when it is first accessed.
/// The implementation is permitted to eagerly fetch data for which the LAZY
/// strategy hint has been specified.
enum FetchType {
  /// Defines that data must be eagerly fetched.
  EAGER,

  /// Defines that data can be lazily fetched.
  LAZY
}

/// The simplest type of mapping to a database column. The Basic annotation can
/// be applied to a persistent property or instance variable of any of the
/// following types: Java primitive types, wrappers of the primitive types.
/// The use of the Basic annotation is optional for persistent fields
/// and properties of these types. If the Basic annotation is not specified
/// for such a field or property, the default values of the Basic
/// annotation will apply.
class Basic {
  /// Defines whether the value of the field or property may be null.
  final bool optional;

  /// Defines whether the value of the field or property should
  /// be lazily loaded or must be eagerly fetched.
  final FetchType fetchType;

  const Basic({this.optional, this.fetchType});
}

/// Specifies a many-valued association with many-to-many multiplicity.
/// Every many-to-many association has two sides, the owning side and the
/// non-owning, or inverse, side. The join table is specified on the owning
/// side. If the association is bidirectional, either side may be designated
/// as the owning side. If the relationship is bidirectional, the non-owning
/// side must use the mappedBy element of the ManyToMany annotation to specify
/// the relationship field or property of the owning side. The join table for
/// the relationship, if not defaulted, is specified on the owning side.
/// The ManyToMany annotation may be used within an embeddable class
/// contained within an entity class to specify a relationship to a collection
/// of entities. If the relationship is bidirectional and the entity containing
/// the embeddable class is the owner of the relationship, the non-owning side
/// must use the mappedBy element of the ManyToMany annotation to specify the
/// relationship field or property of the embeddable class. The dot (".")
/// notation syntax must be used in the mappedBy element to indicate the
/// relationship attribute within the embedded attribute. The value of each
/// identifier used with the dot notation is the name of the respective embedded
/// field or property.
class ManyToMany {
  /// The operations that must be cascaded to the target of the association.
  final List<CascadeType> cascade;

  /// Whether the association should be lazily loaded
  /// or must be eagerly fetched.
  final FetchType fetchType;

  /// The field that owns the relationship.
  final String mappedBy;

  /// The entity class that is the target of the association.
  final Type targetEntity;

  const ManyToMany(
      {this.cascade = const [],
      this.mappedBy = "",
      this.targetEntity,
      this.fetchType = FetchType.LAZY});
}

/// Specifies a many-valued association with many-to-many multiplicity.
/// Every many-to-many association has two sides, the owning side and the
/// non-owning, or inverse, side. The join table is specified on the owning
/// side. If the association is bidirectional, either side may be designated
/// as the owning side. If the relationship is bidirectional, the non-owning
/// side must use the mappedBy element of the ManyToMany annotation to specify
/// the relationship field or property of the owning side. The join table for
/// the relationship, if not defaulted, is specified on the owning side.
/// The ManyToMany annotation may be used within an embeddable class
/// contained within an entity class to specify a relationship to a collection
/// of entities. If the relationship is bidirectional and the entity containing
/// the embeddable class is the owner of the relationship, the non-owning side
/// must use the mappedBy element of the ManyToMany annotation to specify the
/// relationship field or property of the embeddable class. The dot (".")
/// notation syntax must be used in the mappedBy element to indicate the
/// relationship attribute within the embedded attribute. The value of each
/// identifier used with the dot notation is the name of the respective embedded
/// field or property.
const ManyToMany manyToMany = ManyToMany();

/// Specifies a single-valued association to another entity class that has
/// many-to-one multiplicity. It is not normally necessary to specify the
/// target entity explicitly since it can usually be inferred from the type
/// of the object being referenced. If the relationship is bidirectional,
/// the non-owning OneToMany entity side must used the mappedBy element to
/// specify the relationship field or property of the entity that is the owner
/// of the relationship. The ManyToOne annotation may be used within an
/// embeddable class to specify a relationship from the embeddable class to an
/// entity class. If the relationship is bidirectional, the non-owning
/// OneToMany entity side must use the mappedBy element of the OneToMany
/// annotation to specify the relationship field or property of the embeddable
/// field or property on the owning side of the relationship. The dot (".")
/// notation syntax must be used in the mappedBy element to indicate the
/// relationship attribute within the embedded attribute. The value of each
/// identifier used with the dot notation is the name of the respective
/// embedded field or property.
class ManyToOne {
  /// The operations that must be cascaded to the target of the association.
  final List<CascadeType> cascade;

  /// Whether the association should be lazily loaded
  /// or must be eagerly fetched.
  final FetchType fetchType;

  /// Whether the association is optional.
  final bool optional;

  /// The entity class that is the target of the association.
  final Type targetEntity;

  const ManyToOne(
      {this.cascade = const [],
      this.fetchType = FetchType.EAGER,
      this.optional = true,
      this.targetEntity
      });
}

/// Specifies a single-valued association to another entity class that has
/// many-to-one multiplicity. It is not normally necessary to specify the
/// target entity explicitly since it can usually be inferred from the type
/// of the object being referenced. If the relationship is bidirectional,
/// the non-owning OneToMany entity side must used the mappedBy element to
/// specify the relationship field or property of the entity that is the owner
/// of the relationship. The ManyToOne annotation may be used within an
/// embeddable class to specify a relationship from the embeddable class to an
/// entity class. If the relationship is bidirectional, the non-owning
/// OneToMany entity side must use the mappedBy element of the OneToMany
/// annotation to specify the relationship field or property of the embeddable
/// field or property on the owning side of the relationship. The dot (".")
/// notation syntax must be used in the mappedBy element to indicate the
/// relationship attribute within the embedded attribute. The value of each
/// identifier used with the dot notation is the name of the respective
/// embedded field or property.
const ManyToOne manyToOne = ManyToOne();

/// Specifies a composite primary key class that is mapped to multiple fields
/// or properties of the entity. The names of the fields or properties in the
/// primary key class and the primary key fields or properties of the entity
/// must correspond and their types must be the same.
class IdClass {
  final Type value;

  const IdClass(this.value);
}

/// Specifies a composite primary key class that is mapped to multiple fields or
/// properties of the entity. The names of the fields or properties in the
/// primary key class and the primary key fields or properties of the entity
/// must correspond and their types must be the same.
class MapKey {
  /// The name of the persistent field or property of the associated entity
  /// that is used as the map key.
  final String name;

  const MapKey({this.name = ""});
}

/// Specifies a composite primary key class that is mapped to multiple fields or
/// properties of the entity. The names of the fields or properties in the
/// primary key class and the primary key fields or properties of the entity
/// must correspond and their types must be the same.
const MapKey mapKey = MapKey();

/// Specifies the type of the map key for associations of type java.util.Map.
/// The map key can be a basic type, an embeddable class, or an entity. If the
/// map is specified using Java generics, the MapKeyClass annotation and
/// associated type need not be specified; otherwise they must be specified.
/// The MapKeyClass annotation is used in conjunction with ElementCollection
/// or one of the collection-valued relationship annotations
/// (OneToMany or ManyToMany). The MapKey annotation is not used when
/// MapKeyClass is specified and vice versa.
class MapKeyClass {
  /// The type of the map key.
  final Type value;

  const MapKeyClass(this.value);
}

/// Specifies the mapping for the key column of a map whose map key is a basic
/// type. If the name element is not specified, it defaults to the concatenation
/// of the following: the name of the referencing relationship field or
/// property; "_"; "KEY".
class MapKeyColumn {
  /// The SQL fragment that is used when generating the DDL for the column.
  final String columnDefinition;

  /// Whether the column is included in SQL INSERT statements generated
  /// by the persistence provider.
  final bool insertable;

  /// The column length.
  final int length;

  /// The name of the map key column.
  final String name;

  /// Whether the database column is nullable.
  final bool nullable;

  /// The precision for a decimal (exact numeric) column.
  final int precision;

  /// The scale for a decimal (exact numeric) column.
  final int scale;

  /// The name of the table that contains the column.
  final String table;

  ///  Whether the column is a unique key.
  final bool unique;

  /// Whether the column is included in SQL UPDATE statements
  /// generated by the persistence provider.
  final bool updatable;

  const MapKeyColumn(
      {this.columnDefinition = "",
      this.insertable = true,
      this.length = 255,
      this.name = "",
      this.nullable = false,
      this.precision = 0,
      this.scale = 0,
      this.table = "",
      this.unique = false,
      this.updatable = true});
}

/// Specifies the mapping for the key column of a map whose map key is a basic
/// type. If the name element is not specified, it defaults to the concatenation
/// of the following: the name of the referencing relationship field or
/// property; "_"; "KEY".
const MapKeyColumn mapKeyColumn = MapKeyColumn();

/// Specifies the enum type for a map key whose basic type is an enumerated
/// type. The MapKeyEnumerated annotation can be applied to an element
/// collection or relationship of type java.util.Map, in conjunction with the
/// ElementCollection, OneToMany, or ManyToMany annotation. If the enumerated
/// type is not specified or the MapKeyEnumerated annotation is not used, the
/// enumerated type is assumed to be ORDINAL.
class MapKeyEnumerated {
  /// The type used in mapping a map key enum type.
  final EnumType value;

  const MapKeyEnumerated({this.value = EnumType.ORDINAL});
}

/// Specifies the enum type for a map key whose basic type is an enumerated
/// type. The MapKeyEnumerated annotation can be applied to an element
/// collection or relationship of type java.util.Map, in conjunction with the
/// ElementCollection, OneToMany, or ManyToMany annotation. If the enumerated
/// type is not specified or the MapKeyEnumerated annotation is not used, the
/// enumerated type is assumed to be ORDINAL.
const MapKeyEnumerated mapKeyEnumerated = MapKeyEnumerated();

/// Specifies a mapping to an entity that is a map key. The map key join column
/// is in the collection table, join table, or table of the target entity
/// that is used to represent the map. If no MapKeyJoinColumn annotation
/// is specified, a single join column is assumed and the default values apply.
class MapKeyJoinColumn {
  /// The SQL fragment that is used when generating the DDL for the column.
  final String columnDefinition;

  /// Used to specify or control the generation of a foreign key constraint
  /// when table generation is in effect.
  final ForeignKey foreignKey;

  /// Whether the column is included in SQL INSERT statements generated
  /// by the persistence provider.
  final bool insertable;

  /// The name of the foreign key column.
  final String name;

  /// Whether the foreign key column is nullable.
  final bool nullable;

  /// The name of the column referenced by this foreign key column.
  final String referencedColumnName;

  /// The name of the table that contains the column.
  final String table;

  /// Whether the property is a unique key.
  final bool unique;

  /// Whether the column is included in SQL UPDATE statements generated
  /// by the persistence provider.
  final bool updatable;

  const MapKeyJoinColumn(
      {this.columnDefinition = "",
      this.foreignKey =
          const ForeignKey(constraintMode: ConstraintMode.PROVIDER_DEFAULT),
      this.referencedColumnName = "",
      this.insertable = true,
      this.nullable = false,
      this.updatable = true,
      this.unique = false,
      this.table = "",
      this.name = ""});
}

/// Specifies a mapping to an entity that is a map key. The map key join column
/// is in the collection table, join table, or table of the target entity
/// that is used to represent the map. If no MapKeyJoinColumn annotation
/// is specified, a single join column is assumed and the default values apply.
const MapKeyJoinColumn mapKeyJoinColumn = MapKeyJoinColumn();

/// Supports composite map keys that reference entities. The MapKeyJoinColumns
/// annotation groups MapKeyJoinColumn annotations. When the MapKeyJoinColumns
/// annotation is used, both the name and the referencedColumnName elements
/// must be specified in each of the grouped MapKeyJoinColumn annotations.
class MapKeyJoinColumns {
  /// Used to specify or control the generation of a foreign key constraint
  /// when table generation is in effect.
  final ForeignKey foreignKey;

  /// The map key join columns that are used to map to the entity that
  /// is the map key.
  final List<MapKeyJoinColumn> value;

  const MapKeyJoinColumns(
      {this.foreignKey =
          const ForeignKey(constraintMode: ConstraintMode.PROVIDER_DEFAULT),
      @required this.value});
}

/// Type used to indicate a specific date mapping.
enum TemporalType { DATE, TIME, TIMESTAMP }

/// This annotation must be specified for persistent map keys of type Date
/// and Calendar. It may only be specified for map keys of these types
class MapKeyTemporal {
  /// The type used in mapping.
  final TemporalType value;

  const MapKeyTemporal(this.value);
}

/// Designates a class whose mapping information is applied to the entities that
/// inherit from it. A mapped superclass has no separate table defined for it.
/// A class designated with the MappedSuperclass annotation can be mapped in the
/// same way as an entity except that the mappings will apply only to its
/// subclasses since no table exists for the mapped superclass itself. When
/// applied to the subclasses the inherited mappings will apply in the context
/// of the subclass tables. Mapping information may be overridden in such
/// subclasses by using the AttributeOverride and AssociationOverride
/// annotations or corresponding XML elements.
class MappedSuperClass {
  const MappedSuperClass();
}

/// Designates a class whose mapping information is applied to the entities that
/// inherit from it. A mapped superclass has no separate table defined for it.
/// A class designated with the MappedSuperclass annotation can be mapped in the
/// same way as an entity except that the mappings will apply only to its
/// subclasses since no table exists for the mapped superclass itself. When
/// applied to the subclasses the inherited mappings will apply in the context
/// of the subclass tables. Mapping information may be overridden in such
/// subclasses by using the AttributeOverride and AssociationOverride
/// annotations or corresponding XML elements.
const MappedSuperClass mappedSuperClass = MappedSuperClass();

/// Designates a ManyToOne or OneToOne relationship attribute that provides
/// the mapping for an EmbeddedId primary key, an attribute within an EmbeddedId
/// primary key, or a simple primary key of the parent entity. The value element
/// specifies the attribute within a composite key to which the relationship
/// attribute corresponds. If the entity's primary key is of the same Java type
/// as the primary key of the entity referenced by the relationship, the value
/// attribute is not specified.
class MapsId {
  /// The name of the attribute within the composite key to which the
  /// relationship attribute corresponds.
  final String value;

  const MapsId({this.value});
}

/// Designates a ManyToOne or OneToOne relationship attribute that provides
/// the mapping for an EmbeddedId primary key, an attribute within an EmbeddedId
/// primary key, or a simple primary key of the parent entity. The value element
/// specifies the attribute within a composite key to which the relationship
/// attribute corresponds. If the entity's primary key is of the same Java type
/// as the primary key of the entity referenced by the relationship, the value
/// attribute is not specified.
const MapsId mapsId = MapsId();

/// A NamedAttributeNode is a member element of a NamedEntityGraph.
class NamedAttributeNode {
  /// The name of the attribute that must be included in the graph.
  final String value;

  /// If the attribute references a Map type, this element can be used to
  /// specify a subgraph for the Key in the case of an Entity key type.
  final String keySubgraph;

  /// If the attribute references a managed type that has its own
  /// AttributeNodes, this element is used to refer to that
  /// NamedSubgraph definition.
  final String subgraph;

  const NamedAttributeNode({
    @required this.value,
    this.keySubgraph = "",
    this.subgraph = "",
  });
}

/// A NamedSubgraph is a member element of a NamedEntityGraph. The NamedSubgraph
/// is only referenced from within a NamedEntityGraph and can not be referenced
/// independently. It is referenced by its name from a NamedAttributeNode
/// element of the NamedEntityGraph.
class NamedSubgraph {
  /// The list of the attributes of the class that must be included.
  final List<NamedAttributeNode> attributeNodes;

  /// The name of the subgraph as referenced from a NamedAttributeNode element.
  final String name;

  /// The type represented by this subgraph.
  final Type type;

  const NamedSubgraph(
      {@required this.name, @required this.attributeNodes, this.type});
}

/// Used to specify the path and boundaries for a find operation or query.
class NamedEntityGraph {
  /// A list of attributes of the entity that are included in this graph.
  final List<NamedAttributeNode> attributeNodes;

  /// Includes all of the attributes of the annotated entity class as attribute
  /// nodes in the NamedEntityGraph without the need to explicitly list them.
  final bool includeAllAttributes;

  /// The name of the entity graph.
  final String name;

  /// A list of subgraphs that will add additional attributes for subclasses
  /// of the annotated entity class to the entity graph.
  final List<NamedSubgraph> subclassSubgraphs;

  /// A list of subgraphs that are included in the entity graph.
  final List<NamedSubgraph> subgraphs;

  const NamedEntityGraph({
    this.includeAllAttributes = false,
    this.subclassSubgraphs = const [],
    this.attributeNodes = const [],
    this.subgraphs = const [],
    this.name = "",
  });
}

/// Used to specify the path and boundaries for a find operation or query.
const NamedEntityGraph namedEntityGraph = NamedEntityGraph();

/// Used to group NamedEntityGraph annotations.
class NamedEntityGraphs {
  final List<NamedEntityGraph> value;

  const NamedEntityGraphs(this.value);
}

/// Used to supply a query property or hint to the NamedQuery or
/// NamedNativeQuery annotation. Vendor-specific hints that are not
/// recognized by a provider are ignored.
class QueryHint {
  /// Name of the hint.
  final String name;

  /// Value of the hint.
  final String value;

  const QueryHint({
    @required this.value,
    @required this.name,
  });
}

/// Specifies a named native SQL query. Query names are scoped to the
/// persistence unit. The NamedNativeQuery annotation can be applied
/// to an entity or mapped superclass.
class NamedNativeQuery {
  /// The name used to refer to the query with the EntityManager methods
  /// that create query objects.
  final String name;

  /// The SQL query string.
  final String query;

  /// Query properties and hints.
  final List<QueryHint> hints;

  /// The class of the result.
  final Type resultClass;

  /// The name of a SqlResultSetMapping, as defined in metadata.
  final String resultSetMapping;

  const NamedNativeQuery(
      {@required this.name,
      @required this.query,
      this.hints = const [],
      this.resultClass,
      this.resultSetMapping = ""});
}

/// Specifies multiple native SQL named queries. Query names are scoped to the
/// persistence unit. The NamedNativeQueries annotation can be applied to an
/// entity or mapped superclass.
class NamedNativeQueries {
  /// Array of NamedNativeQuery annotations.
  final List<NamedNativeQuery> value;

  const NamedNativeQueries(this.value);
}

enum LockModeType {
  NONE,
  OPTIMISTIC,
  OPTIMISTIC_FORCE_INCREMENT,
  PESSIMISTIC_FORCE_INCREMENT,
  PESSIMISTIC_READ,
  PESSIMISTIC_WRITE,

  /// Synonymous with OPTIMISTIC.
  READ,

  /// Synonymous with OPTIMISTIC_FORCE_INCREMENT.
  WRITE
}

/// Specifies a static, named query in the Java Persistence query language.
/// Query names are scoped to the persistence unit. The NamedQuery annotation
/// can be applied to an entity or mapped superclass.
/// @NamedQuery(
//            name="findAllCustomersWithName",
//            query="SELECT c FROM Customer c WHERE c.name LIKE :customName"
//    )
class NamedQuery {
  /// The name used to refer to the query with the EntityManager
  /// methods that create query objects.
  final String name;

  /// The query string in the Java Persistence query language.
  final String query;

  /// Query properties and hints.
  final List<QueryHint> hints;

  /// The lock mode type to use in query execution.
  final LockModeType lockMode;

  const NamedQuery(
      {@required this.name,
      @required this.query,
      this.hints = const [],
      this.lockMode = LockModeType.NONE});
}

/// Specifies multiple named Java Persistence query language queries.
/// Query names are scoped to the persistence unit. The NamedQueries
/// annotation can be applied to an entity or mapped superclass.
class NamedQueries {
  final List<NamedQuery> value;

  const NamedQueries(this.value);
}

/// Specifies whether an entity should be cached if caching is enabled when the
/// value of the persistence.xml caching element is ENABLE_SELECTIVE or
/// DISABLE_SELECTIVE. The value of the Cacheable annotation is inherited by
/// subclasses; it can be overridden by specifying Cacheable on a subclass.
/// Cacheable(false) means that the entity and its state must not be
/// cached by the provider.
class Cacheable {
  /// Whether or not the entity should be cached.
  final bool value;

  const Cacheable([this.value = true]);
}

/// Specifies whether an entity should be cached if caching is enabled when the
/// value of the persistence.xml caching element is ENABLE_SELECTIVE or
/// DISABLE_SELECTIVE. The value of the Cacheable annotation is inherited by
/// subclasses; it can be overridden by specifying Cacheable on a subclass.
/// Cacheable(false) means that the entity and its state must not be
/// cached by the provider.
const Cacheable cacheable = Cacheable();

/// Specifies the table that is used for the mapping of collections of basic or
/// embeddable types. Applied to the collection-valued field or property.
/// By default, the columns of the collection table that correspond to the
/// embeddable class or basic type are derived from the attributes of the
/// embeddable class or from the basic type according to the default values
/// of the Column annotation. In the case of a basic type, the column name is
/// derived from the name of the collection-valued field or property. In the
/// case of an embeddable class, the column names are derived from the field
/// or property names of the embeddable class.
/// To override the default properties of the column used for a basic type, the
/// Column annotation is used on the collection-valued attribute in addition to
/// the ElementCollection annotation.
/// To override these defaults for an embeddable class, the AttributeOverride
/// and/or AttributeOverrides annotations can be used in addition to the
/// ElementCollection annotation. If the embeddable class contains references
/// to other entities, the default values for the columns corresponding to those
/// references may be overridden by means of the AssociationOverride and/or
/// AssociationOverrides annotations.
/// If the CollectionTable annotation is missing, the default values of the
/// CollectionTable annotation elements apply.
///    Example:
///
///    @Embeddable public class Address {
///       protected String street;
///       protected String city;
///       protected String state;
///       ...
///     }
///
///    @Entity public class Person {
///       @Id protected String ssn;
///       protected String name;
///       protected Address home;
///       ...
///       @ElementCollection  // use default table (PERSON_NICKNAMES)
///       @Column(name="name", length=50)
///       protected Set<String> nickNames = new HashSet();
///       ...
///    }
///
///    @Entity public class WealthyPerson extends Person {
///       @ElementCollection
///       @CollectionTable(name="HOMES") // use default join column name
///       @AttributeOverrides({
///          @AttributeOverride(name="street",
///                             column=@Column(name="HOME_STREET")),
///          @AttributeOverride(name="city",
///                             column=@Column(name="HOME_CITY")),
///          @AttributeOverride(name="state",
///                             column=@Column(name="HOME_STATE"))
///        })
///       protected Set<Address> vacationHomes = new HashSet();
///       ...
///    }
class CollectionTable {
  /// The catalog of the table.
  final String catalog;

  /// Used to specify or control the generation of a foreign key constraint for
  /// the columns corresponding to the joinColumns element when table
  /// generation is in effect.
  final ForeignKey foreignKey;

  /// Indexes for the table.
  final List<Index> indexes;

  /// The foreign key columns of the collection table which
  /// reference the primary table of the entity.
  final List<JoinColumn> joinColumns;

  /// The name of the collection table.
  final String name;

  /// The schema of the table.
  final String schema;

  /// Unique constraints that are to be placed on the table.
  final List<UniqueConstraint> uniqueConstraints;

  const CollectionTable({
    this.catalog = "",
    this.schema = "",
    this.name = "",
    this.uniqueConstraints = const [],
    this.joinColumns = const [],
    this.indexes = const [],
    this.foreignKey =
        const ForeignKey(constraintMode: ConstraintMode.PROVIDER_DEFAULT),
  });
}

/// Specifies the mode of a parameter of a stored procedure query.
enum ParameterMode {
  /// Stored procedure input parameter
  IN,

  /// Stored procedure input/output parameter
  INOUT,

  /// Stored procedure output parameter
  OUT,

  /// Stored procedure reference cursor parameter.
  REF_CURSOR
}

/// Specifies a parameter of a named stored procedure query. All parameters
/// of a named stored procedure query must be specified.
class StoredProcedureParameter {
  
  final Type type;

  /// Specifies whether the parameter is an IN, INOUT, OUT,
  /// or REF_CURSOR parameter.
  final ParameterMode mode;

  /// The name of the parameter as defined by the stored
  /// procedure in the database.
  final String name;

  const StoredProcedureParameter(
      {@required this.type, this.mode = ParameterMode.IN, this.name = ""});
}

class NamedStoredProcedureQuery {
  /// The name used to refer to the query with the EntityManager
  /// methods that create stored procedure query objects.
  final String name;

  /// The name of the stored procedure in the database.
  final String procedureName;

  /// Query properties and hints.
  final List<QueryHint> hints;

  /// Information about all parameters of the stored procedure.
  final List<StoredProcedureParameter> parameters;

  /// The class or classes that are used to map the results.
  final List<Type> resultClasses;

  /// The names of one or more result set mappings, as defined in metadata.
  final List<String> resultSetMappings;

  const NamedStoredProcedureQuery(
      {@required this.name,
      @required this.procedureName,
      this.hints = const [],
      this.parameters = const [],
      this.resultClasses = const [],
      this.resultSetMappings = const []});
}

/// Specifies multiple named stored procedure queries. Query names are scoped
/// to the persistence unit. The NamedStoredProcedureQueries annotation can be
/// applied to an entity or mapped superclass.
class NamedStoredProcedureQueries {
  /// Array of NamedStoredProcedureQuery annotations.
  final List<NamedStoredProcedureQuery> value;

  const NamedStoredProcedureQueries(this.value);
}

/// Specifies a many-valued association with one-to-many multiplicity. If the
/// collection is defined using generics to specify the element type, the
/// associated target entity type need not be specified; otherwise the target
/// entity class must be specified. If the relationship is bidirectional, the
/// mappedBy element must be used to specify the relationship field or property
/// of the entity that is the owner of the relationship. The OneToMany
/// annotation may be used within an embeddable class contained within an entity
/// class to specify a relationship to a collection of entities. If the
/// relationship is bidirectional, the mappedBy element must be used to specify
/// the relationship field or property of the entity that is the owner of the
/// relationship. When the collection is a Map, the cascade element
/// and the orphanRemoval element apply to the map value.
class OneToMany {
  /// The operations that must be cascaded to the target of the association.
  final List<CascadeType> cascade;

  /// Whether the association should be lazily loaded or must be
  /// eagerly fetched.
  final FetchType fetch;

  /// The field that owns the relationship.
  final String mappedBy;

  /// Whether to apply the remove operation to entities that have been
  /// removed from the relationship and to cascade the remove
  /// operation to those entities.
  final bool orphanRemoval;

  /// The entity class that is the target of the association.
  final Type targetEntity;

  const OneToMany(
      {this.cascade = const [],
      this.fetch = FetchType.LAZY,
      this.mappedBy = "",
      this.orphanRemoval = false,
      this.targetEntity});
}

/// Specifies a many-valued association with one-to-many multiplicity. If the
/// collection is defined using generics to specify the element type, the
/// associated target entity type need not be specified; otherwise the target
/// entity class must be specified. If the relationship is bidirectional, the
/// mappedBy element must be used to specify the relationship field or property
/// of the entity that is the owner of the relationship. The OneToMany
/// annotation may be used within an embeddable class contained within an entity
/// class to specify a relationship to a collection of entities. If the
/// relationship is bidirectional, the mappedBy element must be used to specify
/// the relationship field or property of the entity that is the owner of the
/// relationship. When the collection is a Map, the cascade element
/// and the orphanRemoval element apply to the map value.
const OneToMany oneToMany = OneToMany();

/// Specifies a single-valued association to another entity that has one-to-one
/// multiplicity. It is not normally necessary to specify the associated target
/// entity explicitly since it can usually be inferred from the type of the
/// object being referenced. If the relationship is bidirectional,
/// the non-owning side must use the mappedBy element of the OneToOne annotation
/// to specify the relationship field or property of the owning side.
/// The OneToOne annotation may be used within an embeddable class to specify
/// a relationship from the embeddable class to an entity class.
/// If the relationship is bidirectional and the entity containing the
/// embeddable class is on the owning side of the relationship, the non-owning
/// side must use the mappedBy element of the OneToOne annotation to specify the
/// relationship field or property of the embeddable class. The dot (".")
/// notation syntax must be used in the mappedBy element to indicate the
/// relationship attribute within the embedded attribute. The value of each
/// identifier used with the dot notation is the name of the respective
/// embedded field or property.
class OneToOne {
  /// The operations that must be cascaded to the target of the association.
  final List<CascadeType> cascade;

  /// Whether the association should be lazily loaded or must be
  /// eagerly fetched.
  final FetchType fetch;

  /// The field that owns the relationship.
  final String mappedBy;

  /// Whether to apply the remove operation to entities that have been
  /// removed from the relationship and to cascade the remove
  /// operation to those entities.
  final bool orphanRemoval;

  /// The entity class that is the target of the association.
  final Type targetEntity;

  const OneToOne(
      {this.cascade = const [],
      this.fetch = FetchType.EAGER,
      this.mappedBy = "",
      this.orphanRemoval = false,
      this.targetEntity});
}

/// Specifies a single-valued association to another entity that has one-to-one
/// multiplicity. It is not normally necessary to specify the associated target
/// entity explicitly since it can usually be inferred from the type of the
/// object being referenced. If the relationship is bidirectional,
/// the non-owning side must use the mappedBy element of the OneToOne annotation
/// to specify the relationship field or property of the owning side.
/// The OneToOne annotation may be used within an embeddable class to specify
/// a relationship from the embeddable class to an entity class.
/// If the relationship is bidirectional and the entity containing the
/// embeddable class is on the owning side of the relationship, the non-owning
/// side must use the mappedBy element of the OneToOne annotation to specify the
/// relationship field or property of the embeddable class. The dot (".")
/// notation syntax must be used in the mappedBy element to indicate the
/// relationship attribute within the embedded attribute. The value of each
/// identifier used with the dot notation is the name of the respective
/// embedded field or property.
const OneToOne oneToOne = OneToOne();

/// Specifies the ordering of the elements of a collection valued association
/// or element collection at the point when the association or collection is
/// retrieved. The syntax of the value ordering element
/// is an orderby_list, as follows:
///    orderby_list::= orderby_item [,orderby_item]*
///    orderby_item::= [property_or_field_name] [ASC | DESC]
/// If ASC or DESC is not specified, ASC (ascending order) is assumed. If the
/// ordering element is not specified for an entity association, ordering by the
/// primary key of the associated entity is assumed. The property or field name
/// must correspond to that of a persistent property or field of the associated
/// class or embedded class within it. The properties or fields used in the
/// ordering must correspond to columns for which comparison operators
/// are supported. The dot (".") notation is used to refer to an attribute
/// within an embedded attribute. The value of each identifier used with the dot
/// notation is the name of the respective embedded field or property.
/// The OrderBy annotation may be applied to an element collection. When OrderBy
/// is applied to an element collection of basic type, the ordering will be by
/// value of the basic objects and the property or field name is not used. When
/// specifying an ordering over an element collection of embeddable type, the
/// dot notation must be used to specify the attribute or attributes that
/// determine the ordering. The OrderBy annotation is not used when an order
/// column is specified
class OrderBy {
  /// An orderby_list.
  final String value;

  const OrderBy([this.value = ""]);
}

/// Specifies the ordering of the elements of a collection valued association
/// or element collection at the point when the association or collection is
/// retrieved. The syntax of the value ordering element
/// is an orderby_list, as follows:
///    orderby_list::= orderby_item [,orderby_item]*
///    orderby_item::= [property_or_field_name] [ASC | DESC]
/// If ASC or DESC is not specified, ASC (ascending order) is assumed. If the
/// ordering element is not specified for an entity association, ordering by the
/// primary key of the associated entity is assumed. The property or field name
/// must correspond to that of a persistent property or field of the associated
/// class or embedded class within it. The properties or fields used in the
/// ordering must correspond to columns for which comparison operators
/// are supported. The dot (".") notation is used to refer to an attribute
/// within an embedded attribute. The value of each identifier used with the dot
/// notation is the name of the respective embedded field or property.
/// The OrderBy annotation may be applied to an element collection. When OrderBy
/// is applied to an element collection of basic type, the ordering will be by
/// value of the basic objects and the property or field name is not used. When
/// specifying an ordering over an element collection of embeddable type, the
/// dot notation must be used to specify the attribute or attributes that
/// determine the ordering. The OrderBy annotation is not used when an order
/// column is specified
const OrderBy orderBy = OrderBy();

/// Specifies a column that is used to maintain the persistent order of a list.
/// The persistence provider is responsible for maintaining the order upon
/// retrieval and in the database. The persistence provider is responsible for
/// updating the ordering upon flushing to the database to reflect any
/// insertion, deletion, or reordering affecting the list. The OrderColumn
/// annotation is specified on a OneToMany or ManyToMany relationship or on an
/// element collection. The OrderColumn annotation is specified on the side of
/// the relationship that references the collection that is to be ordered. The
/// order column is not visible as part of the state of the entity or embeddable
/// class. The OrderBy annotation should be used for ordering that is visible as
/// persistent state and maintained by the application. The OrderBy annotation
/// is not used when OrderColumn is specified. The order column must be of
/// integral type. The persistence provider maintains a contiguous (non-sparse)
/// ordering of the values of the order column when updating the association or
/// element collection. The order column value for the first element is 0
class OrderColumn {
  /// The SQL fragment that is used when generating the DDL for the column.
  final String columnDefinition;

  /// Whether the column is included in SQL INSERT statements generated
  /// by the persistence provider.
  final bool insertable;

  /// The name of the ordering column.
  final String name;

  /// Whether the database column is nullable.
  final bool nullable;

  /// Whether the column is included in SQL UPDATE statements generated
  /// by the persistence provider.
  final bool updatable;

  const OrderColumn({
    this.name = "",
    this.nullable = true,
    this.insertable = true,
    this.updatable = true,
    this.columnDefinition = "",
  });
}


/// Specifies a primary key column that is used as a foreign key to join to
/// another table. It is used to join the primary table of an entity subclass in
/// the JOINED mapping strategy to the primary table of its superclass; it is
/// used within a SecondaryTable annotation to join a secondary table to a
/// primary table; and it may be used in a OneToOne mapping in which the primary
/// key of the referencing entity is used as a foreign key to the referenced
/// entity. If no PrimaryKeyJoinColumn annotation is specified for a subclass
/// in the JOINED mapping strategy, the foreign key columns are assumed
/// to have the same names as the primary key columns of the primary
/// table of the superclass.
///
///    Example: Customer and ValuedCustomer subclass
///
///    @Entity
///    @Table(name="CUST")
///    @Inheritance(strategy=JOINED)
///    @DiscriminatorValue("CUST")
///    class Customer { ... }
///
///    @Entity
///    @Table(name="VCUST")
///    @DiscriminatorValue("VCUST")
///    @PrimaryKeyJoinColumn(name="CUST_ID")
///    class ValuedCustomer extends Customer { ... }
class PrimaryKeyJoinColumn {

  /// The SQL fragment that is used when generating the DDL for the column.
  final String columnDefinition;

  /// Used to specify or control the generation of a foreign key constraint for
  /// the primary key join column when table generation is in effect.
  final ForeignKey foreignKey;
  
  /// The name of the primary key column of the current table.
  final String name;
  
  /// The name of the primary key column of the table being joined to.
  final String referencedColumnName;
  
  const PrimaryKeyJoinColumn({
    this.name = "",
    this.referencedColumnName = "",
    this.columnDefinition = "",
    this.foreignKey = const ForeignKey(
      constraintMode: ConstraintMode.PROVIDER_DEFAULT
    )
  });
}

/// Specifies a primary key column that is used as a foreign key to join to
/// another table. It is used to join the primary table of an entity subclass in
/// the JOINED mapping strategy to the primary table of its superclass; it is
/// used within a SecondaryTable annotation to join a secondary table to a
/// primary table; and it may be used in a OneToOne mapping in which the primary
/// key of the referencing entity is used as a foreign key to the referenced
/// entity. If no PrimaryKeyJoinColumn annotation is specified for a subclass
/// in the JOINED mapping strategy, the foreign key columns are assumed
/// to have the same names as the primary key columns of the primary
/// table of the superclass.
///
///    Example: Customer and ValuedCustomer subclass
///
///    @Entity
///    @Table(name="CUST")
///    @Inheritance(strategy=JOINED)
///    @DiscriminatorValue("CUST")
///    class Customer { ... }
///
///    @Entity
///    @Table(name="VCUST")
///    @DiscriminatorValue("VCUST")
///    @PrimaryKeyJoinColumn(name="CUST_ID")
///    class ValuedCustomer extends Customer { ... }
const PrimaryKeyJoinColumn primaryKeyJoinColumn = PrimaryKeyJoinColumn();


/// Groups PrimaryKeyJoinColumn annotations. It is used to map composite
/// foreign keys.
///    Example: ValuedCustomer subclass
///
///    @Entity
///    @Table(name="VCUST")
///    @DiscriminatorValue("VCUST")
///    @PrimaryKeyJoinColumns({
///        @PrimaryKeyJoinColumn(name="CUST_ID",
///            referencedColumnName="ID"),
///        @PrimaryKeyJoinColumn(name="CUST_TYPE",
///            referencedColumnName="TYPE")
///    })
///    class ValuedCustomer extends Customer { ... }
class PrimaryKeyJoinColumns {

  /// Used to specify or control the generation of a foreign key constraint
  /// when table generation is in effect.
  final ForeignKey foreignKey;
  
  /// One or more PrimaryKeyJoinColumn annotations.
  final List<PrimaryKeyJoinColumn> value;
  
  const PrimaryKeyJoinColumns({
    @required this.value,
    this.foreignKey = const ForeignKey(
      constraintMode: ConstraintMode.PROVIDER_DEFAULT
    ),
  });
}

/// Specifies a secondary table for the annotated entity class. Specifying one
/// or more secondary tables indicates that the data for the entity class is
/// stored across multiple tables. If no SecondaryTable annotation is specified,
/// it is assumed that all persistent fields or properties of the entity are
/// mapped to the primary table. If no primary key join columns are specified,
/// the join columns are assumed to reference the primary key columns of the
/// primary table, and have the same names and types as the referenced primary
/// key columns of the primary table.
class SecondaryTable {

  /// The name of the table.
  final String name;
  
  /// The catalog of the table.
  final String catalog;
  
  /// Used to specify or control the generation of a foreign key constraint for
  /// the columns corresponding to the pkJoinColumns element when table
  /// generation is in effect.
  final ForeignKey foreignKey;
  
  ///  Indexes for the table.
  final List<Index> indexes;
  
  /// The columns that are used to join with the primary table.
  final List<PrimaryKeyJoinColumn> pkJoinColumns;
  
  /// The schema of the table.
  final String schema;
  
  /// Unique constraints that are to be placed on the table.
  final List<UniqueConstraint> uniqueConstraints;
  
  const SecondaryTable({
    @required this.name,
    this.catalog = "",
    this.schema = "",
    this.pkJoinColumns = const [],
    this.uniqueConstraints = const [],
    this.indexes = const [],
    this.foreignKey = const ForeignKey(
      constraintMode: ConstraintMode.PROVIDER_DEFAULT
    )
  });
}

/// Specifies multiple secondary tables for an entity.
class SecondaryTables {
  
  /// The secondary tables for an entity.
  final List<SecondaryTable> value;
  const SecondaryTables(this.value);
}

/// Defines a primary key generator that may be referenced by name when a
/// generator element is specified for the GeneratedValue annotation. A sequence
/// generator may be specified on the entity class or on the primary key field
/// or property. The scope of the generator name is global to the persistence
/// unit (across all generator types).
///   Example: @SequenceGenerator(name="EMP_SEQ", allocationSize=25)
class SequenceGenerator {

  /// A unique generator name that can be referenced by one or more classes to
  /// be the generator for primary key values.
  final String name;
  
  /// The amount to increment by when allocating sequence
  /// numbers from the sequence.
  final int allocationSize;
  
  /// The catalog of the sequence generator.
  final String catalog;
  
  /// The value from which the sequence object is to start generating.
  final int initialValue;
  
  /// The schema of the sequence generator.
  final String schema;
  
  /// The name of the database sequence object from which to obtain
  /// primary key values.
  final String sequenceName;
  
  const SequenceGenerator({
    @required this.name,
    this.sequenceName = "",
    this.catalog = "",
    this.schema = "",
    this.initialValue = 1,
    this.allocationSize = 50
  });
}

/// Used in conjunction with the SqlResultSetMapping annotation or
/// ConstructorResult annotation to map a column of the SELECT list of a SQL
/// query. The name element references the name of a column in the SELECT list
///  i.e., column alias, if applicable. Scalar result types can be included in
/// the query result by specifying this annotation in the metadata.
class ColumnResult {

  /// The name of a column in the SELECT clause of a SQL query
  final String name;
  
  /// The type to which the column type is to be mapped.
  final Type type;
  
  const ColumnResult({
    @required this.name,
    this.type
  });
}

/// Used in conjunction with the SqlResultSetMapping annotation to map the
/// SELECT clause of a SQL query to a constructor. Applies a constructor for the
/// target class, passing in as arguments values from the specified columns. All
/// columns corresponding to arguments of the intended constructor must be
/// specified using the columns element of the ConstructorResult annotation in
/// the same order as that of the argument list of the constructor. Any entities
/// returned as constructor results will be in either the new or detached state,
/// depending on whether a primary key is retrieved for the constructed object.
class ConstructorResult {

  /// The mapping of columns in the SELECT list to the arguments of the intended
  /// constructor, in order.
  final List<ColumnResult> columns;
  
  /// The class whose constructor is to be invoked.
  final Type targetClass;
  
  const ConstructorResult({
    @required this.targetClass,
    @required this.columns,
  });
}

/// Used in conjunction with the EntityResult annotation to map columns
/// specified in the SELECT list of a SQL query to the properties or fields of
/// an entity class.
class FieldResult {

  /// Name of the column in the SELECT clause - i.e., column aliases,
  /// if applicable.
  final String column;
  
  /// Name of the persistent field or property of the class.
  final String name;
  
  const FieldResult({
    @required this.column,
    @required this.name
  });
}

/// Used in conjunction with the SqlResultSetMapping annotation to map the
/// SELECT clause of a SQL query to an entity result. If this annotation is
/// used, the SQL statement should select all of the columns that are mapped to
/// the entity object. This should include foreign key columns to related
/// entities. The results obtained when insufficient data is
/// available are undefined.
class EntityResult {

  /// The class of the result.
  final Type entityClass;
  
  /// Specifies the column name (or alias) of the column in the SELECT list that
  /// is used to determine the type of the entity instance.
  final String discriminatorColumn;
  
  /// Maps the columns specified in the SELECT list of the query to the
  /// properties or fields of the entity class.
  final List<FieldResult> fields;
  
  const EntityResult({
    @required this.entityClass,
    this.discriminatorColumn,
    this.fields
  });
}


/// Specifies the mapping of the result of a native SQL query
/// or stored procedure.
///    Example:
///
///    Query q = em.createNativeQuery(
///        "SELECT o.id AS order_id, " +
///            "o.quantity AS order_quantity, " +
///            "o.item AS order_item, " +
///            "i.name AS item_name, " +
///        "FROM Order o, Item i " +
///        "WHERE (order_quantity > 25) AND (order_item = i.id)",
///    "OrderResults");
///
///    @SqlResultSetMapping(name="OrderResults",
///        entities={
///            @EntityResult(entityClass=com.acme.Order.class, fields={
///                @FieldResult(name="id", column="order_id"),
///                @FieldResult(name="quantity", column="order_quantity"),
///                @FieldResult(name="item", column="order_item")})},
///        columns={
///            @ColumnResult(name="item_name")}
///    )
///
class SqlResultSetMapping {

  /// The name given to the result set mapping, and used to refer to it in the
  /// methods of the Query and StoredProcedureQuery APIs.
  final String name;
  
  /// Specifies the result set mapping to constructors.
  final List<ConstructorResult> classes;
  
  /// Specifies the result set mapping to scalar values.
  final List<ColumnResult> columns;
  
  /// Specifies the result set mapping to entities.
  final List<EntityResult> entities;
  
  const SqlResultSetMapping({
    @required this.name,
    this.classes = const [],
    this.columns = const [],
    this.entities = const [],
  });
}


/// Is used to define one or more SqlResultSetMapping annotations.
class SqlResultSetMappings {

  /// One or more SqlResultSetMapping annotations.
  final List<SqlResultSetMapping> value;
  const SqlResultSetMappings(this.value);
}


/// Specifies the primary table for the annotated entity. Additional tables may
/// be specified using SecondaryTable or SecondaryTables annotation. If no Table
/// annotation is specified for an entity class, the default values apply.
///
///    Example:
///
///    @Entity
///    @Table(name="CUST", schema="RECORDS")
///    class Customer { ... }
class Table {
  
  /// The catalog of the table.
  final String catalog;
  
  /// Indexes for the table.
  final List<Index> indexes;
  
  /// The name of the table.
  final String name;
  
  /// The schema of the table.
  final String schema;
  
  /// Unique constraints that are to be placed on the table.
  final List<UniqueConstraint> uniqueConstraints;
  
  const Table({
    this.name = "",
    this.catalog = "",
    this.schema = "",
    this.indexes = const [],
    this.uniqueConstraints = const [],
  });
}

/// Specifies the primary table for the annotated entity. Additional tables may
/// be specified using SecondaryTable or SecondaryTables annotation. If no Table
/// annotation is specified for an entity class, the default values apply.
///
///    Example:
///
///    @Entity
///    @Table(name="CUST", schema="RECORDS")
///    class Customer { ... }
const Table table = Table();


/// This annotation must be specified for persistent fields or properties of
/// type java.util.Date and java.util.Calendar. It may only be specified for
/// fields or properties of these types. The Temporal annotation may be used in
/// conjunction with the Basic annotation, the Id annotation, or the
/// ElementCollection annotation (when the element collection value is of such a
/// temporal type
class Temporal {

  /// The type used in mapping.
  final TemporalType value;
  const Temporal(this.value);
}


/// Specifies the version field or property of an entity class that serves as
/// its optimistic lock value. The version is used to ensure integrity when
/// performing the merge operation and for optimistic concurrency control.
/// Only a single Version property or field should be used per class;
/// applications that use more than one Version property or field will not be
/// portable. The Version property should be mapped to the primary table for the
/// entity class; applications that map the Version property to a table other
/// than the primary table will not be portable.
class Version {
  const Version();
}

/// Specifies the version field or property of an entity class that serves as
/// its optimistic lock value. The version is used to ensure integrity when
/// performing the merge operation and for optimistic concurrency control.
/// Only a single Version property or field should be used per class;
/// applications that use more than one Version property or field will not be
/// portable. The Version property should be mapped to the primary table for the
/// entity class; applications that map the Version property to a table other
/// than the primary table will not be portable.
const Version version = Version();


/// Defines a primary key generator that may be referenced by name when a
/// generator element is specified for the GeneratedValue annotation. A table
/// generator may be specified on the entity class or on the primary key field
/// or property. The scope of the generator name is global to the persistence
/// unit (across all generator types).
class TableGenerator {

  /// A unique generator name that can be referenced by one or more classes
  /// to be the generator for id values.
  final String name;
  
  /// The amount to increment by when allocating id numbers from the generator.
  final int allocationSize;
  
  /// The catalog of the table.
  final String catalog;
  
  /// Indexes for the table.
  final List<Index> indexes;
  
  /// The initial value to be used to initialize the column that stores the last
  /// value generated.
  final int initialValue;
  
  /// Name of the primary key column in the table.
  final String pkColumnName;
  
  /// The primary key value in the generator table that distinguishes this set
  /// of generated values from others that may be stored in the table.
  final String pkColumnValue;
  
  /// The schema of the table.
  final String schema;
  
  /// Name of table that stores the generated id values.
  final String table;
  
  /// Unique constraints that are to be placed on the table.
  final List<UniqueConstraint> uniqueConstraints;
  
  /// Name of the column that stores the last value generated.
  final String valueColumnName;
  
  const TableGenerator({
    @required this.name,
    this.table = "",
    this.catalog = "",
    this.schema = "",
    this.pkColumnName = "",
    this.pkColumnValue = "",
    this.valueColumnName = "",
    this.initialValue = 0,
    this.allocationSize = 50,
    this.uniqueConstraints = const [],
    this.indexes = const [],
  });
}


/// Specifies the conversion of a Basic field or property. It is not necessary
/// to use the Basic annotation or corresponding XML element to specify
/// the Basic type.
class Convert {

  /// The attributeName element must be specified unless the Convert annotation
  /// is on an attribute of basic type or on an element collection of basic type
  final String attributeName;
  
  /// Specifies the converter to be applied.
  final String converter;
  
  /// Used to disable an auto-apply or inherited converter.
  final bool disableConversion;
  
  const Convert({
    this.attributeName = "",
    this.converter = "void",
    this.disableConversion = false
  });
}

/// Specifies the conversion of a Basic field or property. It is not necessary
/// to use the Basic annotation or corresponding XML element to specify
/// the Basic type.
const Convert convert = Convert();


/// Specifies that the annotated class is a converter and defines its scope.
/// A converter class must be annotated with the Converter annotation or defined
/// in the object/relational mapping descriptor as a converter.
class Converter {
  final bool autoApply;
  const Converter([
    this.autoApply = false
  ]);
}

/// Specifies that the annotated class is a converter and defines its scope.
/// A converter class must be annotated with the Converter annotation or defined
/// in the object/relational mapping descriptor as a converter.
const Converter converter = Converter();

/// Used to group Convert annotations. Multiple converters must not be applied
/// to the same basic attribute.
class Converts {
  
  /// The Convert mappings that are to be applied.
  final List<Convert> value;
  const Converts(this.value);
}

/// Defines supported types of the discriminator column.
enum DiscriminatorType {
  CHAR, INTEGER, STRING
}

/// Specifies the value of the discriminator column for entities of the given
/// type. The DiscriminatorValue annotation can only be specified on a concrete
/// entity class. If the DiscriminatorValue annotation is not specified and a
/// discriminator column is used, a provider-specific function will be used to
/// generate a value representing the entity type. If the DiscriminatorType is
/// STRING, the discriminator value default is the entity name. The inheritance
/// strategy and the discriminator column are only specified in the root of an
/// entity class hierarchy or subhierarchy in which a different inheritance
/// strategy is applied. The discriminator value, if not defaulted, should be
/// specified for each entity class in the hierarchy.
class DiscriminatorValue {

  /// The value that indicates that the row is an entity of the
  /// annotated entity type.
  final String value;
  const DiscriminatorValue(this.value);
}

/// Specifies the discriminator column for the SINGLE_TABLE and JOINED
/// Inheritance mapping strategies. The strategy and the discriminator column
/// are only specified in the root of an entity class hierarchy or subhierarchy
/// in which a different inheritance strategy is applied If the
/// DiscriminatorColumn annotation is missing, and a discriminator column is
/// required, the name of the discriminator column defaults to "DTYPE" and the
/// discriminator type to DiscriminatorType.STRING.
///
///     Example:
///
///     @entity
///     @Table(name="CUST")
///     @Inheritance(strategy=SINGLE_TABLE)
///     @DiscriminatorColumn(name="DISC", discriminatorType=STRING, length=20)
///     class Customer { ... }
///
///     @entity
///     class ValuedCustomer extends Customer { ... }
class DiscriminatorColumn {

  /// The SQL fragment that is used when generating the DDL for
  /// the discriminator column.
  final String columnDefinition;
  
  /// The type of object/column to use as a class discriminator.
  final DiscriminatorType discriminatorType;
  
  /// The column length for String-based discriminator types.
  final int length;
  
  /// The name of column to be used for the discriminator.
  final String name;
  
  const DiscriminatorColumn({
    this.name = "DTYPE",
    this.discriminatorType = DiscriminatorType.STRING,
    this.columnDefinition = "",
    this.length = 31
  });
}

/// Specifies the discriminator column for the SINGLE_TABLE and JOINED
/// Inheritance mapping strategies. The strategy and the discriminator column
/// are only specified in the root of an entity class hierarchy or subhierarchy
/// in which a different inheritance strategy is applied If the
/// DiscriminatorColumn annotation is missing, and a discriminator column is
/// required, the name of the discriminator column defaults to "DTYPE" and the
/// discriminator type to DiscriminatorType.STRING.
///
///     Example:
///
///     @entity
///     @Table(name="CUST")
///     @Inheritance(strategy=SINGLE_TABLE)
///     @DiscriminatorColumn(name="DISC", discriminatorType=STRING, length=20)
///     class Customer { ... }
///
///     @entity
///     class ValuedCustomer extends Customer { ... }
const DiscriminatorColumn discriminatorColumn = DiscriminatorColumn();
